// Code generated by go-lsp/cmd/generate; DO NOT EDIT.
// LSP version: 3.17.0

package protocol

import (
	"context"
	"encoding/json"
	"go.lsp.dev/jsonrpc2"
)

// LSP method name constants.
const (
	MethodCancelRequest = "$/cancelRequest"
	MethodProgress = "$/progress"
	MethodSetTrace = "$/setTrace"
	MethodCallHierarchyIncomingCalls = "callHierarchy/incomingCalls"
	MethodCallHierarchyOutgoingCalls = "callHierarchy/outgoingCalls"
	MethodCodeActionResolve = "codeAction/resolve"
	MethodCodeLensResolve = "codeLens/resolve"
	MethodCompletionItemResolve = "completionItem/resolve"
	MethodDocumentLinkResolve = "documentLink/resolve"
	MethodExit = "exit"
	MethodInitialize = "initialize"
	MethodInitialized = "initialized"
	MethodInlayHintResolve = "inlayHint/resolve"
	MethodNotebookDocumentDidChange = "notebookDocument/didChange"
	MethodNotebookDocumentDidClose = "notebookDocument/didClose"
	MethodNotebookDocumentDidOpen = "notebookDocument/didOpen"
	MethodNotebookDocumentDidSave = "notebookDocument/didSave"
	MethodShutdown = "shutdown"
	MethodTextDocumentCodeAction = "textDocument/codeAction"
	MethodTextDocumentCodeLens = "textDocument/codeLens"
	MethodTextDocumentColorPresentation = "textDocument/colorPresentation"
	MethodTextDocumentCompletion = "textDocument/completion"
	MethodTextDocumentDeclaration = "textDocument/declaration"
	MethodTextDocumentDefinition = "textDocument/definition"
	MethodTextDocumentDiagnostic = "textDocument/diagnostic"
	MethodTextDocumentDidChange = "textDocument/didChange"
	MethodTextDocumentDidClose = "textDocument/didClose"
	MethodTextDocumentDidOpen = "textDocument/didOpen"
	MethodTextDocumentDidSave = "textDocument/didSave"
	MethodTextDocumentDocumentColor = "textDocument/documentColor"
	MethodTextDocumentDocumentHighlight = "textDocument/documentHighlight"
	MethodTextDocumentDocumentLink = "textDocument/documentLink"
	MethodTextDocumentDocumentSymbol = "textDocument/documentSymbol"
	MethodTextDocumentFoldingRange = "textDocument/foldingRange"
	MethodTextDocumentFormatting = "textDocument/formatting"
	MethodTextDocumentHover = "textDocument/hover"
	MethodTextDocumentImplementation = "textDocument/implementation"
	MethodTextDocumentInlayHint = "textDocument/inlayHint"
	MethodTextDocumentInlineValue = "textDocument/inlineValue"
	MethodTextDocumentLinkedEditingRange = "textDocument/linkedEditingRange"
	MethodTextDocumentMoniker = "textDocument/moniker"
	MethodTextDocumentOnTypeFormatting = "textDocument/onTypeFormatting"
	MethodTextDocumentPrepareCallHierarchy = "textDocument/prepareCallHierarchy"
	MethodTextDocumentPrepareRename = "textDocument/prepareRename"
	MethodTextDocumentPrepareTypeHierarchy = "textDocument/prepareTypeHierarchy"
	MethodTextDocumentRangeFormatting = "textDocument/rangeFormatting"
	MethodTextDocumentReferences = "textDocument/references"
	MethodTextDocumentRename = "textDocument/rename"
	MethodTextDocumentSelectionRange = "textDocument/selectionRange"
	MethodTextDocumentSemanticTokensFull = "textDocument/semanticTokens/full"
	MethodTextDocumentSemanticTokensFullDelta = "textDocument/semanticTokens/full/delta"
	MethodTextDocumentSemanticTokensRange = "textDocument/semanticTokens/range"
	MethodTextDocumentSignatureHelp = "textDocument/signatureHelp"
	MethodTextDocumentTypeDefinition = "textDocument/typeDefinition"
	MethodTextDocumentWillSave = "textDocument/willSave"
	MethodTextDocumentWillSaveWaitUntil = "textDocument/willSaveWaitUntil"
	MethodTypeHierarchySubtypes = "typeHierarchy/subtypes"
	MethodTypeHierarchySupertypes = "typeHierarchy/supertypes"
	MethodWindowWorkDoneProgressCancel = "window/workDoneProgress/cancel"
	MethodWorkspaceDiagnostic = "workspace/diagnostic"
	MethodWorkspaceDidChangeConfiguration = "workspace/didChangeConfiguration"
	MethodWorkspaceDidChangeWatchedFiles = "workspace/didChangeWatchedFiles"
	MethodWorkspaceDidChangeWorkspaceFolders = "workspace/didChangeWorkspaceFolders"
	MethodWorkspaceDidCreateFiles = "workspace/didCreateFiles"
	MethodWorkspaceDidDeleteFiles = "workspace/didDeleteFiles"
	MethodWorkspaceDidRenameFiles = "workspace/didRenameFiles"
	MethodWorkspaceExecuteCommand = "workspace/executeCommand"
	MethodWorkspaceSymbol = "workspace/symbol"
	MethodWorkspaceWillCreateFiles = "workspace/willCreateFiles"
	MethodWorkspaceWillDeleteFiles = "workspace/willDeleteFiles"
	MethodWorkspaceWillRenameFiles = "workspace/willRenameFiles"
	MethodWorkspaceSymbolResolve = "workspaceSymbol/resolve"
	MethodLogTrace = "$/logTrace"
	MethodClientRegisterCapability = "client/registerCapability"
	MethodClientUnregisterCapability = "client/unregisterCapability"
	MethodTelemetryEvent = "telemetry/event"
	MethodTextDocumentPublishDiagnostics = "textDocument/publishDiagnostics"
	MethodWindowLogMessage = "window/logMessage"
	MethodWindowShowDocument = "window/showDocument"
	MethodWindowShowMessage = "window/showMessage"
	MethodWindowShowMessageRequest = "window/showMessageRequest"
	MethodWindowWorkDoneProgressCreate = "window/workDoneProgress/create"
	MethodWorkspaceApplyEdit = "workspace/applyEdit"
	MethodWorkspaceCodeLensRefresh = "workspace/codeLens/refresh"
	MethodWorkspaceConfiguration = "workspace/configuration"
	MethodWorkspaceDiagnosticRefresh = "workspace/diagnostic/refresh"
	MethodWorkspaceInlayHintRefresh = "workspace/inlayHint/refresh"
	MethodWorkspaceInlineValueRefresh = "workspace/inlineValue/refresh"
	MethodWorkspaceSemanticTokensRefresh = "workspace/semanticTokens/refresh"
	MethodWorkspaceWorkspaceFolders = "workspace/workspaceFolders"
)

// Server defines the interface for an LSP server.
// All methods correspond to LSP requests and notifications
// directed from client to server.
type Server interface {
	// CancelRequest handles the "$/cancelRequest" method.
	CancelRequest(ctx context.Context, params *CancelParams) error
	// Progress handles the "$/progress" method.
	Progress(ctx context.Context, params *ProgressParams) error
	// SetTrace handles the "$/setTrace" method.
	SetTrace(ctx context.Context, params *SetTraceParams) error
	// A request to resolve the incoming calls for a given `CallHierarchyItem`.
	// 
	// @since 3.16.0
	IncomingCalls(ctx context.Context, params *CallHierarchyIncomingCallsParams) ([]CallHierarchyIncomingCall, error)
	// A request to resolve the outgoing calls for a given `CallHierarchyItem`.
	// 
	// @since 3.16.0
	OutgoingCalls(ctx context.Context, params *CallHierarchyOutgoingCallsParams) ([]CallHierarchyOutgoingCall, error)
	// Request to resolve additional information for a given code action.The request's
	// parameter is of type {@link CodeAction} the response
	// is of type {@link CodeAction} or a Thenable that resolves to such.
	CodeActionResolve(ctx context.Context, params *CodeAction) (*CodeAction, error)
	// A request to resolve a command for a given code lens.
	CodeLensResolve(ctx context.Context, params *CodeLens) (*CodeLens, error)
	// Request to resolve additional information for a given completion item.The request's
	// parameter is of type {@link CompletionItem} the response
	// is of type {@link CompletionItem} or a Thenable that resolves to such.
	CompletionResolve(ctx context.Context, params *CompletionItem) (*CompletionItem, error)
	// Request to resolve additional information for a given document link. The request's
	// parameter is of type {@link DocumentLink} the response
	// is of type {@link DocumentLink} or a Thenable that resolves to such.
	DocumentLinkResolve(ctx context.Context, params *DocumentLink) (*DocumentLink, error)
	// The exit event is sent from the client to the server to
	// ask the server to exit its process.
	Exit(ctx context.Context) error
	// The initialize request is sent from the client to the server.
	// It is sent once as the request after starting up the server.
	// The requests parameter is of type {@link InitializeParams}
	// the response if of type {@link InitializeResult} of a Thenable that
	// resolves to such.
	Initialize(ctx context.Context, params *InitializeParams) (*InitializeResult, error)
	// The initialized notification is sent from the client to the
	// server after the client is fully initialized and the server
	// is allowed to send requests from the server to the client.
	Initialized(ctx context.Context, params *InitializedParams) error
	// A request to resolve additional properties for an inlay hint.
	// The request's parameter is of type {@link InlayHint}, the response is
	// of type {@link InlayHint} or a Thenable that resolves to such.
	// 
	// @since 3.17.0
	InlayHintResolve(ctx context.Context, params *InlayHint) (*InlayHint, error)
	// NotebookDocumentDidChange handles the "notebookDocument/didChange" method.
	NotebookDocumentDidChange(ctx context.Context, params *DidChangeNotebookDocumentParams) error
	// A notification sent when a notebook closes.
	// 
	// @since 3.17.0
	NotebookDocumentDidClose(ctx context.Context, params *DidCloseNotebookDocumentParams) error
	// A notification sent when a notebook opens.
	// 
	// @since 3.17.0
	NotebookDocumentDidOpen(ctx context.Context, params *DidOpenNotebookDocumentParams) error
	// A notification sent when a notebook document is saved.
	// 
	// @since 3.17.0
	NotebookDocumentDidSave(ctx context.Context, params *DidSaveNotebookDocumentParams) error
	// A shutdown request is sent from the client to the server.
	// It is sent once when the client decides to shutdown the
	// server. The only notification that is sent after a shutdown request
	// is the exit event.
	Shutdown(ctx context.Context) (any, error)
	// A request to provide commands for the given text document and range.
	CodeAction(ctx context.Context, params *CodeActionParams) ([]any, error)
	// A request to provide code lens for the given text document.
	CodeLens(ctx context.Context, params *CodeLensParams) ([]CodeLens, error)
	// A request to list all presentation for a color. The request's
	// parameter is of type {@link ColorPresentationParams} the
	// response is of type {@link ColorInformation ColorInformation[]} or a Thenable
	// that resolves to such.
	ColorPresentation(ctx context.Context, params *ColorPresentationParams) ([]ColorPresentation, error)
	// Request to request completion at a given text document position. The request's
	// parameter is of type {@link TextDocumentPosition} the response
	// is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}
	// or a Thenable that resolves to such.
	// 
	// The request can delay the computation of the {@link CompletionItem.detail `detail`}
	// and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`
	// request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
	// `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
	Completion(ctx context.Context, params *CompletionParams) (any, error)
	// A request to resolve the type definition locations of a symbol at a given text
	// document position. The request's parameter is of type {@link TextDocumentPositionParams}
	// the response is of type {@link Declaration} or a typed array of {@link DeclarationLink}
	// or a Thenable that resolves to such.
	Declaration(ctx context.Context, params *DeclarationParams) (any, error)
	// A request to resolve the definition location of a symbol at a given text
	// document position. The request's parameter is of type {@link TextDocumentPosition}
	// the response is of either type {@link Definition} or a typed array of
	// {@link DefinitionLink} or a Thenable that resolves to such.
	Definition(ctx context.Context, params *DefinitionParams) (any, error)
	// The document diagnostic request definition.
	// 
	// @since 3.17.0
	Diagnostic(ctx context.Context, params *DocumentDiagnosticParams) (DocumentDiagnosticReport, error)
	// The document change notification is sent from the client to the server to signal
	// changes to a text document.
	DidChange(ctx context.Context, params *DidChangeTextDocumentParams) error
	// The document close notification is sent from the client to the server when
	// the document got closed in the client. The document's truth now exists where
	// the document's uri points to (e.g. if the document's uri is a file uri the
	// truth now exists on disk). As with the open notification the close notification
	// is about managing the document's content. Receiving a close notification
	// doesn't mean that the document was open in an editor before. A close
	// notification requires a previous open notification to be sent.
	DidClose(ctx context.Context, params *DidCloseTextDocumentParams) error
	// The document open notification is sent from the client to the server to signal
	// newly opened text documents. The document's truth is now managed by the client
	// and the server must not try to read the document's truth using the document's
	// uri. Open in this sense means it is managed by the client. It doesn't necessarily
	// mean that its content is presented in an editor. An open notification must not
	// be sent more than once without a corresponding close notification send before.
	// This means open and close notification must be balanced and the max open count
	// is one.
	DidOpen(ctx context.Context, params *DidOpenTextDocumentParams) error
	// The document save notification is sent from the client to the server when
	// the document got saved in the client.
	DidSave(ctx context.Context, params *DidSaveTextDocumentParams) error
	// A request to list all color symbols found in a given text document. The request's
	// parameter is of type {@link DocumentColorParams} the
	// response is of type {@link ColorInformation ColorInformation[]} or a Thenable
	// that resolves to such.
	DocumentColor(ctx context.Context, params *DocumentColorParams) ([]ColorInformation, error)
	// Request to resolve a {@link DocumentHighlight} for a given
	// text document position. The request's parameter is of type {@link TextDocumentPosition}
	// the request response is an array of type {@link DocumentHighlight}
	// or a Thenable that resolves to such.
	DocumentHighlight(ctx context.Context, params *DocumentHighlightParams) ([]DocumentHighlight, error)
	// A request to provide document links
	DocumentLink(ctx context.Context, params *DocumentLinkParams) ([]DocumentLink, error)
	// A request to list all symbols found in a given text document. The request's
	// parameter is of type {@link TextDocumentIdentifier} the
	// response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable
	// that resolves to such.
	DocumentSymbol(ctx context.Context, params *DocumentSymbolParams) (any, error)
	// A request to provide folding ranges in a document. The request's
	// parameter is of type {@link FoldingRangeParams}, the
	// response is of type {@link FoldingRangeList} or a Thenable
	// that resolves to such.
	FoldingRanges(ctx context.Context, params *FoldingRangeParams) ([]FoldingRange, error)
	// A request to format a whole document.
	Formatting(ctx context.Context, params *DocumentFormattingParams) ([]TextEdit, error)
	// Request to request hover information at a given text document position. The request's
	// parameter is of type {@link TextDocumentPosition} the response is of
	// type {@link Hover} or a Thenable that resolves to such.
	Hover(ctx context.Context, params *HoverParams) (*Hover, error)
	// A request to resolve the implementation locations of a symbol at a given text
	// document position. The request's parameter is of type {@link TextDocumentPositionParams}
	// the response is of type {@link Definition} or a Thenable that resolves to such.
	Implementation(ctx context.Context, params *ImplementationParams) (any, error)
	// A request to provide inlay hints in a document. The request's parameter is of
	// type {@link InlayHintsParams}, the response is of type
	// {@link InlayHint InlayHint[]} or a Thenable that resolves to such.
	// 
	// @since 3.17.0
	InlayHint(ctx context.Context, params *InlayHintParams) ([]InlayHint, error)
	// A request to provide inline values in a document. The request's parameter is of
	// type {@link InlineValueParams}, the response is of type
	// {@link InlineValue InlineValue[]} or a Thenable that resolves to such.
	// 
	// @since 3.17.0
	InlineValue(ctx context.Context, params *InlineValueParams) ([]InlineValue, error)
	// A request to provide ranges that can be edited together.
	// 
	// @since 3.16.0
	LinkedEditingRange(ctx context.Context, params *LinkedEditingRangeParams) (*LinkedEditingRanges, error)
	// A request to get the moniker of a symbol at a given text document position.
	// The request parameter is of type {@link TextDocumentPositionParams}.
	// The response is of type {@link Moniker Moniker[]} or `null`.
	Moniker(ctx context.Context, params *MonikerParams) ([]Moniker, error)
	// A request to format a document on type.
	OnTypeFormatting(ctx context.Context, params *DocumentOnTypeFormattingParams) ([]TextEdit, error)
	// A request to result a `CallHierarchyItem` in a document at a given position.
	// Can be used as an input to an incoming or outgoing call hierarchy.
	// 
	// @since 3.16.0
	PrepareCallHierarchy(ctx context.Context, params *CallHierarchyPrepareParams) ([]CallHierarchyItem, error)
	// A request to test and perform the setup necessary for a rename.
	// 
	// @since 3.16 - support for default behavior
	PrepareRename(ctx context.Context, params *PrepareRenameParams) (*PrepareRenameResult, error)
	// A request to result a `TypeHierarchyItem` in a document at a given position.
	// Can be used as an input to a subtypes or supertypes type hierarchy.
	// 
	// @since 3.17.0
	PrepareTypeHierarchy(ctx context.Context, params *TypeHierarchyPrepareParams) ([]TypeHierarchyItem, error)
	// A request to format a range in a document.
	RangeFormatting(ctx context.Context, params *DocumentRangeFormattingParams) ([]TextEdit, error)
	// A request to resolve project-wide references for the symbol denoted
	// by the given text document position. The request's parameter is of
	// type {@link ReferenceParams} the response is of type
	// {@link Location Location[]} or a Thenable that resolves to such.
	References(ctx context.Context, params *ReferenceParams) ([]Location, error)
	// A request to rename a symbol.
	Rename(ctx context.Context, params *RenameParams) (*WorkspaceEdit, error)
	// A request to provide selection ranges in a document. The request's
	// parameter is of type {@link SelectionRangeParams}, the
	// response is of type {@link SelectionRange SelectionRange[]} or a Thenable
	// that resolves to such.
	SelectionRange(ctx context.Context, params *SelectionRangeParams) ([]SelectionRange, error)
	// @since 3.16.0
	SemanticTokensFull(ctx context.Context, params *SemanticTokensParams) (*SemanticTokens, error)
	// @since 3.16.0
	SemanticTokensFullDelta(ctx context.Context, params *SemanticTokensDeltaParams) (any, error)
	// @since 3.16.0
	SemanticTokensRange(ctx context.Context, params *SemanticTokensRangeParams) (*SemanticTokens, error)
	// SignatureHelp handles the "textDocument/signatureHelp" method.
	SignatureHelp(ctx context.Context, params *SignatureHelpParams) (*SignatureHelp, error)
	// A request to resolve the type definition locations of a symbol at a given text
	// document position. The request's parameter is of type {@link TextDocumentPositionParams}
	// the response is of type {@link Definition} or a Thenable that resolves to such.
	TypeDefinition(ctx context.Context, params *TypeDefinitionParams) (any, error)
	// A document will save notification is sent from the client to the server before
	// the document is actually saved.
	WillSave(ctx context.Context, params *WillSaveTextDocumentParams) error
	// A document will save request is sent from the client to the server before
	// the document is actually saved. The request can return an array of TextEdits
	// which will be applied to the text document before it is saved. Please note that
	// clients might drop results if computing the text edits took too long or if a
	// server constantly fails on this request. This is done to keep the save fast and
	// reliable.
	WillSaveWaitUntil(ctx context.Context, params *WillSaveTextDocumentParams) ([]TextEdit, error)
	// A request to resolve the subtypes for a given `TypeHierarchyItem`.
	// 
	// @since 3.17.0
	Subtypes(ctx context.Context, params *TypeHierarchySubtypesParams) ([]TypeHierarchyItem, error)
	// A request to resolve the supertypes for a given `TypeHierarchyItem`.
	// 
	// @since 3.17.0
	Supertypes(ctx context.Context, params *TypeHierarchySupertypesParams) ([]TypeHierarchyItem, error)
	// The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
	// initiated on the server side.
	WorkDoneProgressCancel(ctx context.Context, params *WorkDoneProgressCancelParams) error
	// The workspace diagnostic request definition.
	// 
	// @since 3.17.0
	WorkspaceDiagnostic(ctx context.Context, params *WorkspaceDiagnosticParams) (*WorkspaceDiagnosticReport, error)
	// The configuration change notification is sent from the client to the server
	// when the client's configuration has changed. The notification contains
	// the changed configuration as defined by the language client.
	DidChangeConfiguration(ctx context.Context, params *DidChangeConfigurationParams) error
	// The watched files notification is sent from the client to the server when
	// the client detects changes to file watched by the language client.
	DidChangeWatchedFiles(ctx context.Context, params *DidChangeWatchedFilesParams) error
	// The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
	// folder configuration changes.
	DidChangeWorkspaceFolders(ctx context.Context, params *DidChangeWorkspaceFoldersParams) error
	// The did create files notification is sent from the client to the server when
	// files were created from within the client.
	// 
	// @since 3.16.0
	DidCreateFiles(ctx context.Context, params *CreateFilesParams) error
	// The will delete files request is sent from the client to the server before files are actually
	// deleted as long as the deletion is triggered from within the client.
	// 
	// @since 3.16.0
	DidDeleteFiles(ctx context.Context, params *DeleteFilesParams) error
	// The did rename files notification is sent from the client to the server when
	// files were renamed from within the client.
	// 
	// @since 3.16.0
	DidRenameFiles(ctx context.Context, params *RenameFilesParams) error
	// A request send from the client to the server to execute a command. The request might return
	// a workspace edit which the client will apply to the workspace.
	ExecuteCommand(ctx context.Context, params *ExecuteCommandParams) (*LSPAny, error)
	// A request to list project-wide symbols matching the query string given
	// by the {@link WorkspaceSymbolParams}. The response is
	// of type {@link SymbolInformation SymbolInformation[]} or a Thenable that
	// resolves to such.
	// 
	// @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
	// need to advertise support for WorkspaceSymbols via the client capability
	// `workspace.symbol.resolveSupport`.
	Symbols(ctx context.Context, params *WorkspaceSymbolParams) (any, error)
	// The will create files request is sent from the client to the server before files are actually
	// created as long as the creation is triggered from within the client.
	// 
	// The request can return a `WorkspaceEdit` which will be applied to workspace before the
	// files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file
	// to be created.
	// 
	// @since 3.16.0
	WillCreateFiles(ctx context.Context, params *CreateFilesParams) (*WorkspaceEdit, error)
	// The did delete files notification is sent from the client to the server when
	// files were deleted from within the client.
	// 
	// @since 3.16.0
	WillDeleteFiles(ctx context.Context, params *DeleteFilesParams) (*WorkspaceEdit, error)
	// The will rename files request is sent from the client to the server before files are actually
	// renamed as long as the rename is triggered from within the client.
	// 
	// @since 3.16.0
	WillRenameFiles(ctx context.Context, params *RenameFilesParams) (*WorkspaceEdit, error)
	// A request to resolve the range inside the workspace
	// symbol's location.
	// 
	// @since 3.17.0
	WorkspaceSymbolResolve(ctx context.Context, params *WorkspaceSymbol) (*WorkspaceSymbol, error)

	// Request is a catch-all handler for any LSP method not covered by the
	// interface above.  The method string is the raw LSP method name and
	// params is the already-decoded parameter value.
	Request(ctx context.Context, method string, params any) (any, error)
}

// serverDispatch dispatches a JSON-RPC request to the appropriate Server method.
func serverDispatch(ctx context.Context, server Server, reply jsonrpc2.Replier, req jsonrpc2.Request) error {
	switch req.Method() {
	case "$/cancelRequest":
		var params CancelParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		return server.CancelRequest(ctx, &params)
	case "$/progress":
		var params ProgressParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		return server.Progress(ctx, &params)
	case "$/setTrace":
		var params SetTraceParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		return server.SetTrace(ctx, &params)
	case "callHierarchy/incomingCalls":
		var params CallHierarchyIncomingCallsParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.IncomingCalls(ctx, &params)
		return reply(ctx, result, err)
	case "callHierarchy/outgoingCalls":
		var params CallHierarchyOutgoingCallsParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.OutgoingCalls(ctx, &params)
		return reply(ctx, result, err)
	case "codeAction/resolve":
		var params CodeAction
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.CodeActionResolve(ctx, &params)
		return reply(ctx, result, err)
	case "codeLens/resolve":
		var params CodeLens
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.CodeLensResolve(ctx, &params)
		return reply(ctx, result, err)
	case "completionItem/resolve":
		var params CompletionItem
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.CompletionResolve(ctx, &params)
		return reply(ctx, result, err)
	case "documentLink/resolve":
		var params DocumentLink
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.DocumentLinkResolve(ctx, &params)
		return reply(ctx, result, err)
	case "exit":
		return server.Exit(ctx)
	case "initialize":
		var params InitializeParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.Initialize(ctx, &params)
		return reply(ctx, result, err)
	case "initialized":
		var params InitializedParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		return server.Initialized(ctx, &params)
	case "inlayHint/resolve":
		var params InlayHint
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.InlayHintResolve(ctx, &params)
		return reply(ctx, result, err)
	case "notebookDocument/didChange":
		var params DidChangeNotebookDocumentParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		return server.NotebookDocumentDidChange(ctx, &params)
	case "notebookDocument/didClose":
		var params DidCloseNotebookDocumentParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		return server.NotebookDocumentDidClose(ctx, &params)
	case "notebookDocument/didOpen":
		var params DidOpenNotebookDocumentParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		return server.NotebookDocumentDidOpen(ctx, &params)
	case "notebookDocument/didSave":
		var params DidSaveNotebookDocumentParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		return server.NotebookDocumentDidSave(ctx, &params)
	case "shutdown":
		result, err := server.Shutdown(ctx)
		return reply(ctx, result, err)
	case "textDocument/codeAction":
		var params CodeActionParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.CodeAction(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/codeLens":
		var params CodeLensParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.CodeLens(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/colorPresentation":
		var params ColorPresentationParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.ColorPresentation(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/completion":
		var params CompletionParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.Completion(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/declaration":
		var params DeclarationParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.Declaration(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/definition":
		var params DefinitionParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.Definition(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/diagnostic":
		var params DocumentDiagnosticParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.Diagnostic(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/didChange":
		var params DidChangeTextDocumentParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		return server.DidChange(ctx, &params)
	case "textDocument/didClose":
		var params DidCloseTextDocumentParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		return server.DidClose(ctx, &params)
	case "textDocument/didOpen":
		var params DidOpenTextDocumentParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		return server.DidOpen(ctx, &params)
	case "textDocument/didSave":
		var params DidSaveTextDocumentParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		return server.DidSave(ctx, &params)
	case "textDocument/documentColor":
		var params DocumentColorParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.DocumentColor(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/documentHighlight":
		var params DocumentHighlightParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.DocumentHighlight(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/documentLink":
		var params DocumentLinkParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.DocumentLink(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/documentSymbol":
		var params DocumentSymbolParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.DocumentSymbol(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/foldingRange":
		var params FoldingRangeParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.FoldingRanges(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/formatting":
		var params DocumentFormattingParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.Formatting(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/hover":
		var params HoverParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.Hover(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/implementation":
		var params ImplementationParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.Implementation(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/inlayHint":
		var params InlayHintParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.InlayHint(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/inlineValue":
		var params InlineValueParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.InlineValue(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/linkedEditingRange":
		var params LinkedEditingRangeParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.LinkedEditingRange(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/moniker":
		var params MonikerParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.Moniker(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/onTypeFormatting":
		var params DocumentOnTypeFormattingParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.OnTypeFormatting(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/prepareCallHierarchy":
		var params CallHierarchyPrepareParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.PrepareCallHierarchy(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/prepareRename":
		var params PrepareRenameParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.PrepareRename(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/prepareTypeHierarchy":
		var params TypeHierarchyPrepareParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.PrepareTypeHierarchy(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/rangeFormatting":
		var params DocumentRangeFormattingParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.RangeFormatting(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/references":
		var params ReferenceParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.References(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/rename":
		var params RenameParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.Rename(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/selectionRange":
		var params SelectionRangeParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.SelectionRange(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/semanticTokens/full":
		var params SemanticTokensParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.SemanticTokensFull(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/semanticTokens/full/delta":
		var params SemanticTokensDeltaParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.SemanticTokensFullDelta(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/semanticTokens/range":
		var params SemanticTokensRangeParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.SemanticTokensRange(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/signatureHelp":
		var params SignatureHelpParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.SignatureHelp(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/typeDefinition":
		var params TypeDefinitionParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.TypeDefinition(ctx, &params)
		return reply(ctx, result, err)
	case "textDocument/willSave":
		var params WillSaveTextDocumentParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		return server.WillSave(ctx, &params)
	case "textDocument/willSaveWaitUntil":
		var params WillSaveTextDocumentParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.WillSaveWaitUntil(ctx, &params)
		return reply(ctx, result, err)
	case "typeHierarchy/subtypes":
		var params TypeHierarchySubtypesParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.Subtypes(ctx, &params)
		return reply(ctx, result, err)
	case "typeHierarchy/supertypes":
		var params TypeHierarchySupertypesParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.Supertypes(ctx, &params)
		return reply(ctx, result, err)
	case "window/workDoneProgress/cancel":
		var params WorkDoneProgressCancelParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		return server.WorkDoneProgressCancel(ctx, &params)
	case "workspace/diagnostic":
		var params WorkspaceDiagnosticParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.WorkspaceDiagnostic(ctx, &params)
		return reply(ctx, result, err)
	case "workspace/didChangeConfiguration":
		var params DidChangeConfigurationParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		return server.DidChangeConfiguration(ctx, &params)
	case "workspace/didChangeWatchedFiles":
		var params DidChangeWatchedFilesParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		return server.DidChangeWatchedFiles(ctx, &params)
	case "workspace/didChangeWorkspaceFolders":
		var params DidChangeWorkspaceFoldersParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		return server.DidChangeWorkspaceFolders(ctx, &params)
	case "workspace/didCreateFiles":
		var params CreateFilesParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		return server.DidCreateFiles(ctx, &params)
	case "workspace/didDeleteFiles":
		var params DeleteFilesParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		return server.DidDeleteFiles(ctx, &params)
	case "workspace/didRenameFiles":
		var params RenameFilesParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		return server.DidRenameFiles(ctx, &params)
	case "workspace/executeCommand":
		var params ExecuteCommandParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.ExecuteCommand(ctx, &params)
		return reply(ctx, result, err)
	case "workspace/symbol":
		var params WorkspaceSymbolParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.Symbols(ctx, &params)
		return reply(ctx, result, err)
	case "workspace/willCreateFiles":
		var params CreateFilesParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.WillCreateFiles(ctx, &params)
		return reply(ctx, result, err)
	case "workspace/willDeleteFiles":
		var params DeleteFilesParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.WillDeleteFiles(ctx, &params)
		return reply(ctx, result, err)
	case "workspace/willRenameFiles":
		var params RenameFilesParams
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.WillRenameFiles(ctx, &params)
		return reply(ctx, result, err)
	case "workspaceSymbol/resolve":
		var params WorkspaceSymbol
		if err := json.Unmarshal(req.Params(), &params); err != nil {
			return replyParseError(ctx, reply, err)
		}
		result, err := server.WorkspaceSymbolResolve(ctx, &params)
		return reply(ctx, result, err)
	default:
		var params any
		if req.Params() != nil {
			if err := json.Unmarshal(req.Params(), &params); err != nil {
				return replyParseError(ctx, reply, err)
			}
		}
		resp, err := server.Request(ctx, req.Method(), params)
		return reply(ctx, resp, err)
	}
}
